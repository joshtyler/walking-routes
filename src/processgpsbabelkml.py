#!/usr/bin/python3

import argparse
from lxml import etree
import sys

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="""\
	Take one or more KML files generated by gpsbabel
	Extract the bits we are interested in
	Write them to a clean KML file (output to stdout)\
	""")
	parser.add_argument('files', metavar='F', type=str, nargs='+', help='gpsbabel KML files to process')
	args = parser.parse_args()

	output_root = create_top_level_kml()
	folder = add_folder_to_kml(output_root, "Walks")

	for file in args.files:
		process_kml_file(folder, file)


# The structure of the gpsbabel generated docuemnt is:
# Folder (name="Routes")
# 	Folder (name=**route_name1**)
#		Placemark (name="Path") [data is here]
# 	Folder (name=**route_name2**)
#		Placemark (name="Path") [data is here]

# Flatten this to:
# Folder (name="Walking Routes")
# 	Folder (name=**route_name1**)
#		Placemark (name="Path") [data is here]
# 	Folder (name=**route_name2**)
#		Placemark (name="Path") [data is here]

# Annoyingly KML files have the default namespace set to this
# This is a bit of a pain to parse in lxml, but oh well...
kml_default_namespace="http://www.opengis.net/kml/2.2"
ns = {"kml":kml_default_namespace}

def create_top_level_kml():
	# Create an output document for us to write to
	return etree.Element("kml", nsmap={None: kml_default_namespace})

def add_folder_to_kml(root, name):
	# Add in routes folder
	folder = etree.SubElement(root, "Folder")
	# Name it
	name_element = etree.SubElement(folder,"name")
	name_element.text = name
	return folder

# Take a KML file and process it
# If target name is none, process all entry with built in names
# Otherwise expect one entry and replace name and descriptiond
def process_kml_file(folder, file, name=None, description=None):
	# Parse our input generated by gpsbabel as an element tree
	input_root = etree.parse(file).getroot()

	paths = input_root.findall("./kml:Document/kml:Folder/kml:Folder",ns)
	if name is not None:
		assert(len(paths) == 1)

	for item in paths:
		route_name = item.find("kml:name",ns).text
		print("Found a route: %s" %(route_name), file=sys.stderr)

		# Get the Placemark (the real data)
		placemark = item.find("kml:Placemark",ns)

		# Set the placemark name correctly
		# Prefer to use the name given to us, but otherwise fall back to what is embedded in the file
		placemark_name = placemark.find("kml:name",ns)
		if name is not None:
			route_name = name
		placemark_name.text = route_name

		# Set description if we have one
		if description is not None:
			desc = etree.SubElement(folder, "descripton")
			desc.text = description

		# Remove style data that gpsbabel adds in
		placemark.remove(placemark.find("kml:styleUrl",ns))

		# Append this to the output
		folder.append(placemark)

def print_output_file(root):
	print(etree.tostring(root, pretty_print=True, encoding='unicode'))

#etree.ElementTree(output_root).write("fixedupkml.kml", xml_declaration=True, encoding='UTF-8', pretty_print=True)
